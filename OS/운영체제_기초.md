# 목차

- [목차](#목차)
- [운영체제 개요](#운영체제-개요)
  - [운영체제란](#운영체제란)

# 운영체제 개요

## 운영체제란

- 컴퓨터 하드웨어를 효율적으로 관리하여 성능을 높이고, 사용자에게 편의를 제공하는 프로그램 (SW)

  - 컴퓨터 사용자와 컴퓨터 하드웨어 사이의 중개자 역할
  - 컴퓨터 하드웨어를 관리하는 소프트웨어
  - 정부와 유사하게 생각하면 된다. 정부처럼 그 자체로는 유용한 기능을 수행하지 못하지만 다른 프로그램이 적절하고 효율적이게 작업을 할 수 있도록 환경을 제공한다.

### 컴퓨터 관점

- 컴퓨터 관점에서 운영체제는 하드웨어와 가장 밀접하게 연관된 프로그램으로 **자원 할당자(resource allocator)** 이다
- 운영체제는 CPU 시간, 메모리 공간, 파일 저장 공간, 입출력 장치 등 컴퓨터 시스템이 문제를 해결하기 위해 요구되는 여러 자원들을 관리자로서 동작하며, 특정 프로그램과 사용자에게 작업 수행을 위해 필요한 자원을 할당한다.
- 또한 운영체제는 여러 입출력 장치와 사용자 프로그램을 제어할 수 있는 **제어 프로그램(control program)** 이기도 하다.

### 사용자 관점

- 사용되는 인터페이스에 따라 사용의 편이성과 자원 이용을 적절하게 배분한다.
  <br>
  <br>

# 운영체제 핵심 기능

## 프로세스 관리

### 프로세스 상태

- 생성 상태: 사용자에 의해 프로세스가 생성된 상태
- 준비 상태: CPU에 할당받을 수 있는 상태
- 실행 상태: 프로세스가 CPU를 할당받아 동작 중인 상태
- 대기 상태: 입출력 처리 등으로 인해 CPU를 양도하고 입출력 처리가 완료될 때까지 대기 리스트에서 기다리는 상태
- 완료 상태: CPU를 할당받아 주어진 시간 내에 완전히 수행을 종료한 상태 = 종료 상태
  <br>
  <br>

### 프로세스 상태 전이

- <img src="https://itwiki.kr/images/d/da/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%83%81%ED%83%9C%EC%A0%84%EC%9D%B4%EB%8F%84.png" width =400px>

- 디스패치(Dispatch): 준비 상태에 있는 여러 프로세스 중 실행될 프로세스를 선정하여 CPU 할당 → 문맥교환 발생 ( CPU가 현재 실행 중인 프로세스의 문맥 상태를 PCB에 저장하고 다음 프로세스틔 PCB로 부터 문맥을 복원하는 작업)
- 타이머 런 아웃 = 할당 시간 초과: 할당된 시간이 초과되면 스케줄러에 의해 PCB 저장, CPU 반납 후 다시 준비상태로 전이된다. (타입 슬라이스 만료, 선점 시 타임아웃)
- 블록 = 입출력 발생: 할당된 시간을 초과하기 전에 입출력 같은 사건이 발생하면 스스로 CPU를 반납하고 대기 상태로 전이된다.
- 웨이크 업: 입출력이 종료되면 대기 상태의 프로세스에게 입출력 종료 사실을 wait & signal 등에 의해 알려주고, 준비 상태로 전이된다.
  <br>
  <br>

### 프로세스 스케줄링

: CPU를 사용하려는 프로세스들 사이의 우선순위를 관리하는 작업

- 주요 용어
  - 서비스 시간: 프로세스가 결과를 산출하기까지 소요되는 시간
  - 응답 시간: 프로세스들이 입력되어 서비스를 요청하고, 반응하기 시작할 때까지 소욛히는 시간
  - 반환 시간(Turnarround Time): 프로세스들이 입력되어 수행하고 결과를 산출하기까지 소요되는 시간 = 대기 시간 + 수행 시간
  - 대기 시간: 프로세스가 프로세서에 할당되기까지 큐에 대기하는 시간
  - 평균 대기시간: 프로세스가 대기 큐에서 대기하는 평균 시간
  - 종료 시간
  - 시간 할당량(Time Quantum / Time Slice): 한 프로세스가 프로세서를 독점하는 것을 방지하기 위해 서비스되는 시간 할당량
  - 응답률: (대기 시간 + 서비스 시간) / 서비스 시간
    → HRN(Highest Responce ratio Next)에 사용되며 응답률이 높으면 우선순위가 높다
    <br>
    <br>
- 프로세스 스케줄링 방식
  - 선점형 스케줄링 (Preemptive Scheduling)
    - 하나의 프로세스가 CPU를 차지하고 있을 때, 우선순위가 높은 다른 프로세스가 현재 프로세스를 중단시키고 CPU를 점유하는 스케줄링 방식
    - 장점: 빠른 응답, 대화식 시분할 시스템에 적합
    - 단점: 높은 우선순위 프로세스들이 들어오는 경우 오버헤드
    - 라운도 로빈(RR), SRT, 다단계 큐, 다단계 피드백 큐
  - 비선점형 스케줄링 (Non Preemptive Scheduling)
    - 한 프로세스가 CPU를 할당받으면 작업 종료 후 CPU 반환 시까지 다른 프로세스는 CPU 점유가 불가능한 스케줄링 방식
    - 장점: 응답시간 예상이 용이, 공정
    - 단점: 짧은 작업을 수행하는 프로세스가 긴 작업 종료시ㅅ까지 대기
    - 처리 시간 편차가 적은 특정 프로세스 환경에 적합
    - 우선순위, 기한부,FCFS,HRN,SJF
      <br>
      <br>
- 선점형 스케줄링 알고리즘
  - 라운드로빈: CPU 할당 시간이 동일, 끝나면 준비 큐 리스트의 가장 뒤로 보내짐 (시분할 시스템에 사용)
  - SRT(Shortest Remaining Time first): 짧은 수행시간을 가진 프로세스를 먼저 수행한다, 남은 처리 시간이 더 짧은 프로세스가 준비큐에 생기면 언제라도 프로세스가 선점된다
  - 다단계 큐 (Multi level queue): 작업들을 여러 종류 그룹으로 분할, 여러 개의 큐를 이용하여 상위 단계 작업에 의한 하위 단계 작업이 선점 당함 , 각 큐는 자신만의 독자적인 스케줄링을 가진다
  - 다단계 피드백 큐: 입출력 위주와 CPU 위주인 프로세스의 특성에 따라 큐마다 서로 다른 CPU 시간 할당량을 부여
    FCFS(FIFO) + RR = 새로운 프로세스는 높은 우선순위, 프로세스의 실행시간이 길어질수록 점점 낮은 우선순위 큐로 이동하고 마지막 단계는 라운드로빈 방식을 적용한다
    <br>
    <br>
- 비선점형 스케줄링 알고리즘
  - FCFS(First come first service): 프로세스가 대기 큐에 도착한 순서에 따라 CPU 할당
  - 우선순위 (Priority): 우선순위에 따라 할당, 동일 순위는 FCFS
  - 기한부 (Deadline): 작업들이 명시된 시간이나 기한 내에 완료되도록 계획
  - HRN(Highest Response Ratio Next): 대기 중인 프로세스 중 현재 응답률이 가장 높은 것을 선택, SJF의 약점인 기아(starvation) 현상을 보완하는 기법
  - SJF(Shortest Job First): 프로세스가 도착하는 시점에 따라 그 당시 가장 작은 서비스 시간을 갖는 프로세스가 종료 시까지 자원 점유 → CPU 요규 시간이 긴 프로세스는 기아 현상이 발생한다.
    - 기아현상은 에이징 기법을 통해 도와줄 수 있다
      <br>
      <br>

### 프로세스 교착 상태

: 다중 프로세싱 환경에서 두 개 이상의 프로세스가 특정 자원 할당을 무한정 대기하는 상태

- 발생 조건
  - 상호배제(Mutual Exclusion): 프로세스가 자원을 배타적으로 점유하여 다른 프로세스가 그 자원을 사용할 수 없는 상태
  - 점유와 대기(Hold & wait): 한 프로세스가 자원을 점유하고 있으면서 또 다른 자원을 요청하고 대기하는 상태
  - 비선점(Non Preemption): 한 프로세스가 점유한 자원에 대해 다른 프로세스가 선점할 수 없고 오직 점유한 프로세스만이 해제 가능한 상태
  - 환형 대기(Circular wait): 두 개 이상의 프로세스 간 자원의 점유와 대기가 하나의 원형을 구성한 상태
    <br>
    <br>
- 해결 방법
  - 예방(Prevention): 상호배제를 제외한 나머지 교착상태 발생 조건을 부정하는 방안
  - 회피(Avoidance): 안전한 상태를 유지할 수 있는 요구만 수락 (은행원 알고리즘)
  - 발견(Detection): 시스템의 상태를 감시 알고리즘을 통해 교착 상태 검사 → 자원 할당 그래프
  - 복구(Recovery): 교착상태가 없어질때까지 프로세스를 순차적으로 kill하여 제거
